# <path to game directory>/addons/eventscripts/_engines/python/Lib/esutils/
# delays.py
# by Adam Cunnington

"""Provide optimised methods which enable a user to delay the execution of 
callables in the primary gamethread.

"""

import bisect
import functools
import time

import es


__all__ = (
    "DelaysError",  
    "Delay", 
)


class DelaysError(Exception):
    """General error encountered relating to esutils.delays"""


class Delay(object):
    """Recurringly or singularly call a given name after <interval> seconds."""
    
    _delays = []

    def __init__(self, callable_name, *args, **kwargs):
        """Instantiate a Delay object.
        
        Arguments:
        callable_name - the name of the callable.
        args - the positional arguments to be passed to the callable.
        kwargs - the keyword arguments to be passed to the callable.
        
        """
        self._callable_name = functools.partial(callable_name, *args, **kwargs)
        self.running = False

    @classmethod
    def _tick(cls):
        if not cls._delays:
            return
        call_time, delay = cls._delays[0]
        now = time.time()
        if now < call_time:
            return
        delay._callable_name()
        del cls._delays[0]
        if not delay.recurring:
            delay.running = False
            if not cls._delays:
                es.addons.unregisterTickListener(cls._tick)
        else:
            delay.call_time = now + delay.interval
            bisect.insort_left(cls._delays, (delay.call_time, delay))
    
    def start(self, interval, recurring=False, call_now=False):
        """Start the delay.
        
        Arguments:
        interval - the number of seconds to delay the call by.
        recurring (Keyword Default: False) - whether or not the delay should 
        happen recurringly or just be a singular occurence.
        call_now (Keyword Default: False) - whether or not the delayed 
        callable should also be called now.
        
        """
        if self.running:
            raise DelaysError("this delay object is already running")
        self.interval = interval
        self.recurring = recurring
        self.call_time = time.time() + interval
        if not self._delays:
            es.addons.registerTickListener(self._tick)
        bisect.insort_left(self._delays, (self.call_time, self))
        self.running = True
        if call_now:
            self._callable_name()
    
    def stop(self):
        """"Cancel the delay and break any looped call."""
        if not self.running:
            raise DelaysError("this delay object is not running")
        self._delays.remove((self.call_time, self))
        self.running = False
        if not self._delays:
            es.addons.unregisterTickListener(self._tick)