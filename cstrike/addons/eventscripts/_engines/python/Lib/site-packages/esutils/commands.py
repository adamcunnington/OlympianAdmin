# <path to game directory>/addons/eventscripts/_engines/python/Lib/esutils/
# commands.py
# by Adam Cunnington

"""Provides a powerful API to facilitate the registering of client console,
client say and server commands. Also, give methods to manage access
to client commands and catch arguments passed with commands.

"""

import shlex

import psyco
psyco.full()

from esutils import clients, messages
import es


__all__ = (
    "ABSENT",
    "ArgumentCountError",
    "ArgumentValueError",
    "CommandsError",
    "Callback",
    "ClientConsoleCommand",
    "ClientSayCommand",
    "Parameter",
    "ServerCommand",
    "inform",
    )

_THIS = "_commands"
ABSENT = object()


class ArgumentCountError(Exception):
    """Invalid amount of arguments passed."""


class ArgumentValueError(Exception):
    """Invalid value for an argument passed."""


class CommandsError(Exception):
    """General error encountered relating to esutils.commands"""


class _Command(object):
    def __init__(self, callback):
        self.callback = callback
        self.names = set()
        self.invalid_argument_callback = self._invalid_argument
        self.invalid_syntax_callback = self._invalid_syntax
        self.no_auth_callback = self._no_auth

    @classmethod
    def _get_transformed_args(cls, callback, args, user_ID=None):
        defaults = dict((parameter, parameter.default_value)
                        for parameter in callback.parameters
                        if parameter.default_value is not ABSENT)
        total_args = len(args)
        total_parameters = len(callback.parameters)
        if not (total_parameters >= total_args >=
                total_parameters - len(defaults)):
            raise ArgumentCountError(args)
        transformed_args = []
        for index, arg in enumerate(args):
            parameter = callback.parameters[index]
            if parameter.transformer is not None:
                try:
                    arg = parameter.transformer(arg, user_ID=user_ID)
                except ArgumentValueError:
                    raise ArgumentValueError(parameter, arg)
            transformed_args.append(arg)
        transformed_args.extend(defaults[callback.parameters[index]]
                                for index in xrange(total_args,
                                                    total_parameters))
        return transformed_args

    @classmethod
    def _invalid_argument(cls, informer, command_name, parameter, arg,
                          user_ID=None):
        inform(informer, "Invalid Argument, %s is an invalid value for "
               "parameter, %s." %(arg, parameter.basename), user_ID)

    @classmethod
    def _invalid_syntax(cls, informer, command_name, parameters, args,
                        user_ID=None):
        inform(informer, "Invalid Syntax, parameter syntax: %s %s." %(
               command_name,
               cls._names[command_name].callback.syntax), user_ID)

    @classmethod
    def _no_auth(cls, informer, command_name, user_ID=None):
        inform(informer, "Authorisation Error, you do not have the required "
               "permission to use this command.", user_ID)

    @classmethod
    def _validate(cls, command_name):
        command_name = command_name.lower()
        if "'" in command_name or "\"" in command_name:
            raise CommandsError("%s is invalid. Command names cannot contain "
                                "quotation marks")


class _ClientCommand(_Command):
    def __init__(self, callback):
        """Instantiate a ClientCommand object.

        Arguments:
        callback - the commands.Callback object to be used by this command.

        """
        super(_ClientCommand, self).__init__(callback)
        self.requires_auth = False

    def set_permission(self, permission=None):
        """Cause the command to require a specific permission from the command
        user.

        Arguments:
        permission (Keyword Default: None) - the name of the permission
        required.

        """
        self.requires_auth = True
        self.permission = permission


class Callback(object):
    """Create a callback that can take a number of parameters and can be used
    by several command types.

    """

    def __init__(self, callback, description):
        """Instantiate a Callback object.

        Arguments:
        callback - the name to call when a command is submitted with
        valid syntax and argument values.
        description - a description of the callback's effect.

        """
        self.callback = callback
        self.description = description
        self.parameters = []

    @property
    def syntax(self):
        """Compile and return the syntax of the command using standard
        notation.

        """
        syntax = ""
        for parameter in self.parameters:
            if parameter.default_value is ABSENT:
                syntax += " <%s>" % parameter.basename
            else:
                syntax += " [%s=%s]" %(parameter.basename,
                                       parameter.default_value)
        return syntax


class ClientConsoleCommand(_ClientCommand):
    """Manage a client console command, wrapping es.regclientcmd"""
    _BASENAME = "client"
    _REGISTER_CALLABLE = staticmethod(es.regclientcmd)
    _UNREGISTER_CALLABLE = staticmethod(es.unregclientcmd)
    _VERBOSE_NAME = "Client Console Command"
    _names = {}

    @classmethod
    def _callback(cls):
        user_ID = es.getcmduserid()
        name = es.getargv(0)
        command = cls._names[name]
        if (command.requires_auth and
            not clients.is_user_authorised(es.getplayersteamid(user_ID),
                                           command.permission)):
            command.no_auth_callback(command.INFORMER, name, user_ID)
            return
        args = [es.getargv(arg) for arg in xrange(1, es.getargc())]
        try:
            args = _Command._get_transformed_args(command.callback, args,
                                                  user_ID=user_ID)
        except ArgumentCountError, (args, ):
            command.invalid_syntax_callback(command.INFORMER, name,
                                            command.callback.parameters, args,
                                            user_ID=user_ID)
        except ArgumentValueError, (parameter, arg):
            command.invalid_argument_callback(command.INFORMER, name,
                                              parameter, arg, user_ID=user_ID)
        else:
            command.callback.callback(args, informer=command.INFORMER,
                                      user_ID=user_ID)

    @classmethod
    def _echo(user_ID, text=" "):
        echo = messages.Echo(text)
        echo.send(user_ID)

    INFORMER = _echo

    def register(self, name):
        """Register a command name to trigger the command's callback.

        Arguments:
        name - a command name.

        """
        if name in self._names:
            raise CommandsError("%s is already registered as a %s" %(
                                name, self._VERBOSE_NAME))
        self._validate(name)
        self._REGISTER_CALLABLE(name, "%s/%s" %(_THIS, self._BASENAME),
                                self.callback.description)
        self.names.add(name)
        self._names[name] = self

    def unregister(self, name=None):
        """Unregister one, or all registered command names by omitting a value

        Arguments:
        name (Keyword Default: None) - a command name.

        """
        if name is not None:
            del self._names[name]
            self._UNREGISTER_CALLABLE(name)
        else:
            while self.names:
                name = self.names.pop()
                del self._names[name]
                self._UNREGISTER_CALLABLE(name)


es.addons.registerBlock(_THIS, ClientConsoleCommand._BASENAME,
                           ClientConsoleCommand._callback)


class ClientSayCommand(_ClientCommand):
    """Manage a client say command through a custom say filter in order to
    correctly handle args encapsulated by "".

    """
    _BASENAME = "saycommand"
    _VERBOSE_NAME = "Client Say Command"
    INFORMER = staticmethod(messages.whisper)
    _names = {}

    @classmethod
    def _say_text_filter(cls, user_ID, text, teamonly):
        stripped_text = text.strip("\"")
        name, separator, stripped_text = stripped_text.partition(" ")
        if not name in cls._names:
            return (user_ID, text, teamonly)
        command = cls._names[name]
        if (command.requires_auth and
            not clients.is_user_authorised(es.getplayersteamid(user_ID),
                                           command.permission)):
            command.no_auth_callback(command.INFORMER, name, user_ID)
            return (False, False, False)
        try:
            args = shlex.split(stripped_text)
        except ValueError:
            # If the string does not have a trailing ", it needs appending.
            stripped_text += "\""
            args = shlex.split(stripped_text)
        try:
            args = _Command._get_transformed_args(command.callback, args,
                                                  user_ID=user_ID)
        except ArgumentCountError, (args, ):
            command.invalid_syntax_callback(command.INFORMER, name,
                                            command.callback.parameters, args,
                                            user_ID=user_ID)
        except ArgumentValueError, (parameter, arg):
            command.invalid_argument_callback(command.INFORMER, name,
                                              parameter, arg, user_ID=user_ID)
        else:
            command.callback.callback(args, informer=command.INFORMER,
                                      user_ID=user_ID)
        return (False, False, False)

    def register(self, name):
        """Register a command name to trigger the command's callback.

        Arguments:
        name - a command name.

        """
        if name in self._names:
            raise CommandsError("%s is already registered as a %s" %(
                                name, self._VERBOSE_NAME))
        self._validate(name)
        self.names.add(name)
        self._names[name] = self

    def unregister(self, name=None):
        """Unregister one, or all registered command names by omitting a value

        Arguments:
        name (Keyword Default: None) - a command name.

        """
        if name is not None:
            del self._names[name]
        else:
            while self.names:
                name = self.names.pop()
                del self._names[name]


es.addons.registerSayFilter(ClientSayCommand._say_text_filter)


class Parameter(object):
    """Create a parameter that can be used by several commmands."""

    def __init__(self, basename, description, default_value=ABSENT):
        """Instantiate a Parameter object.

        Arguments:
        basename - the basename to identify the parameter by.
        description - a description of the values accepted.
        default_value (Keyword Default: ABSENT) - the default value the
        parameter should take. A value other than the default, ABSENT object
        will cause the parameter to be optional.

        """
        self.basename = basename
        self.description = description
        self.default_value = default_value
        self.transformer = None

    def set_transformer(self, transformer):
        """Set a transformer for the argument value to pass through before it
        is sent to the parameter.

        Arguments:
        transformer - the name of the callable.

        """
        self.transformer = transformer


class ServerCommand(_Command):
    """Manage a client console command, wrapping es.regcmd"""
    _BASENAME = "server"
    _REGISTER_CALLABLE = staticmethod(es.regcmd)
    _VERBOSE_NAME = "Server Command"
    INFORMER = staticmethod(messages.output)
    _names = {}

    def __init__(self, callback):
        """Instantiate a ServerCommand object.

        Arguments:
        callback - the commands.Callback object to be used by this command.

        """
        super(ServerCommand, self).__init__(callback)
        self.names = {}
        self.disabled_callback = self._disabled

    @classmethod
    def _callback(cls):
        name = es.getargv(0)
        command = cls._names[name]
        if not command.names[name]:
            command.disabled_callback(command.INFORMER, name)
            return
        args = [es.getargv(arg) for arg in xrange(1, es.getargc())]
        try:
            args = _Command._get_transformed_args(command.callback, args)
        except ArgumentCountError, (args, ):
            command.invalid_syntax_callback(command.INFORMER, name,
                                            command.callback.parameters, args)
        except ArgumentValueError, (parameter, arg):
            command.invalid_argument_callback(command.INFORMER, name,
                                              parameter, arg)
        else:
            command.callback.callback(args, informer=command.INFORMER)

    @classmethod
    def _disabled(cls, informer, command_name):
        inform(informer, "Command Disabled, %s is no longer active." %
               command_name)

    def enable(self, name):
        """Register a command name to trigger the command's callback.

        Arguments:
        name - a command name.

        """
        if name in self._names:
            raise CommandsError("%s is already registered as a %s" %(
                                name, self._VERBOSE_NAME))
        self._REGISTER_CALLABLE(name, "%s/%s" %(_THIS, self._BASENAME),
                                self.callback.description)
        self.names[name] = True
        self._names[name] = self

    def disable(self, name=None):
        """Disable one, or all registered command names by omitting a value

        Arguments:
        name (Keyword Default: None) - a command name.

        """
        if name is not None:
            self.names[name] = False
        else:
            for name in self.names:
                self.names[name] = False


es.addons.registerBlock(_THIS, ServerCommand._BASENAME,
                        ServerCommand._callback)


def inform(informer, message, user_ID=None):
    if user_ID is None:
        informer(message)
    else:
        informer(user_ID, message)