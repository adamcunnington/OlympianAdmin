 # <path to game directory>/addons/eventscripts/_engines/python/Lib/esutils/
# menus.py
# by Adam Cunnington

"""Provides a powerful API to allow the user to create & manage menus
consisting of options. Also, manage menu selections and send them to an
explictly registered callback function.

"""

import shlex

import psyco
psyco.full()

from esutils import clients, delays, messages
import es


__all__ = (
    "ABSENT",
    "MenusError",
    "Menu",
    "MenuItem",
    "MenuOption",
    "CustomMenuOption",
    "close_popup",
    "get_popup",
    "resend_last_popup"
    )

_CUSTOM_OPTION_IDENTIFIER = object()
ABSENT = object()


class MenusError(Exception):
    """Generic error encountered relating to esutils.menus"""


class _Player(object):
    def __init__(self):
        self._delay = None
        self.history = []
        self.identifiers = []
        self._input_option = None
        self.popup = None
        self.user_ID = None
        self.items = []


class Menu(object):
    """Create a dynamically constructed menu that can be sent and
    simultaneously viewed by multiple users.

    """

    players = {}

    def __init__(self, callback=None, get_title=None, get_description=None,
                 get_items=None):
        """Instantiate a Menu object.

        Arguments:
        callback (Keyword Default: None) - the name to call when a menu
        item is selected.
        get_title (Keyword Default: None) - the name to call to dynamically
        fetch the menu's title each time the menu is built.
        get_description (Keyword Default: None) - the name to call to
        dynamically fetch the menu's description each time the menu is built.
        get_items (Keyword Default: None) - the name to call to dynamically
        fetch the menu's options each time the menu is built.

        """
        self.callback = callback
        self.get_title = get_title
        self._title = " "
        self.get_description = get_description
        self._description = " "
        self.page_format = "[Page %s/%s]"
        self._separator = "------------------------------"
        self._max_items = 6
        self.get_items = get_items
        self.items = []

    def _build(self, user_ID, page):
        player = self.players[user_ID]
        items = player.items or self.items
        total_items = len(items)
        total_pages, remainder = divmod(max(total_items, 1), self._max_items)
        if remainder:
            total_pages += 1
        selectable_keys = ""
        lines = []
        if self.get_title is None:
            lines.append(self._title)
        else:
            lines.append(self._validate_true_value(
                         self.get_title(user_ID)))
        if self.get_description is None:
            lines.append(self._description)
        else:
            lines.append(self._validate_true_value(self.get_description(
                                                   user_ID)))
        lines.append(self.page_format %(page, total_pages))
        lines.append(self._separator)
        start = (page - 1) * self._max_items
        for i in xrange(self._max_items):
            index = start + i
            number = i + 1
            if index < total_items:
                item = items[index]
                if item.get_text is not None:
                    item.text = item.get_text(user_ID)
                if item.selectable is not None:
                    steam_ID = es.getplayersteamid(user_ID)
                    if item.selectable and (not item.requires_auth or
                        clients.is_user_authorised(steam_ID, item.permission)):
                        lines.append("->%s. %s" %(number, item.text))
                        selectable_keys += str(number)
                    else:
                        lines.append("%s. %s" %(number, item.text))
                else:
                    lines.append(item.text)
            else:
                lines.extend((" ", ) * (self._max_items - (number - 1)))
                break
        lines.append(self._separator)
        if player.history:
            number = "7"
            lines.append("->%s. Previous Popup" % number)
            selectable_keys += number
        else:
            # In order to make the sizes of menus uniform so that navigation
            # between menus looks professional, a blank line needs to be
            # added. Apparently, a space is the minimum for a blank line.
            lines.append(" ")
        if page > 1:
            # This will occur if the user has been explicitly sent a page from
            # a menu greater than 1 with no previous history. In this
            # instance, we want them to be able to access previous pages in
            # the menu.
            number = "8"
            lines.append("->%s. Previous Page" % number)
            selectable_keys += number
        else:
            lines.append(" ")
        if page < total_pages:
            number = "9"
            lines.append("->%s. Next Page" % number)
            selectable_keys += number
        else:
            lines.append(" ")
        number = 0
        lines.append("%s. Close" % number)
        selectable_keys += str(number)
        return "\n".join(lines), selectable_keys

    @classmethod
    def _client_command_filter(cls, user_ID, args=None):
        if (args.pop(0).lower() != "menuselect" or not args or
            not args[0].isdigit() or user_ID not in cls.players):
            # If the command submitted wasn't a valid menu select, we
            # should exit the function immediately.
            return True
        selection = int(args[0])
        if selection not in xrange(1, 11):
            return True
        player = cls.players[user_ID]
        player._delay.stop()
        player._delay = None
        menu, page = player.popup
        if selection == 7:
            del player.history[-1]
            previous_menu, previous_page = player.history.pop()
            if (previous_menu != menu or
                previous_page not in (page - 1, page + 1)):
                del player.identifiers[-1]
            previous_menu.send(user_ID, previous_page, False)
        elif selection == 8:
            menu.send(user_ID, page - 1, False)
        elif selection == 9:
            menu.send(user_ID, page + 1, False)
        elif selection == 10:
            return True
        else:
            if player.items:
                items = player.items[:]
                del player.items[:]
            else:
                items = menu.items
            cls._process_option_selection(player, items[((page - 1) * 6) +
                                                        selection - 1])
        return True

    def _get_description(self):
        return self._description

    def _get_max_items(self):
        return self._max_items

    def _get_separator(self):
        return self._separator

    def _get_title(self):
        return self._title

    @classmethod
    def _player_disconnect(cls, event_var):
        user_ID = int(event_var["userid"])
        if user_ID not in cls.players:
            return
        player = cls.players.pop(user_ID)
        if player._delay is not None:
            player._delay.stop()

    @classmethod
    def _process_option_selection(cls, player, option, custom=False,
                                  custom_identifier=None):
        menu = player.popup[0]
        if not custom:
            if option.identifier != _CUSTOM_OPTION_IDENTIFIER:
                player.identifiers.append(option.identifier)
            else:
                player._input_option = option
                messages.whisper(player.user_ID,
                                 "Please enter a value into chat.")
                return
        else:
            player.identifiers.append(custom_identifier)
            player._input_option = None
        if option.subpopup is not None:
            next_menu, next_page = option.subpopup
            next_menu.send(player.user_ID, next_page, False)
            if not option.send_callback:
                return
        menu.callback(player.user_ID, *player.identifiers[:])

    @classmethod
    def _say_text_filter(cls, user_ID, text, team_only):
        player = cls.players.get(user_ID)
        if player is None or player._input_option is None:
            return (user_ID, text, team_only)
        text = text.strip("\"")
        try:
            args = shlex.split(text)
        except ValueError:
            # If the string does not have a trailing ", it needs appending.
            text += "\""
            args = shlex.split(text)
        text = " ".join(args)
        # Declare variable for readable line length.
        identifier = (player._input_option.transformer(text)
                      if player._input_option.transformer is not None
                      else text)
        cls._process_option_selection(player, player._input_option, True,
                                      identifier)
        return (None, None, None)

    def _set_description(self, value):
        self._description = self._validate_true_value(value)

    description = property(_get_description, _set_description)

    def _set_max_items(self, value):
        if not 0 < value < 7:
            raise ValueError("expected 0 < value < 7")
        self._max_items = value

    max_items = property(_get_max_items, _set_max_items)

    def _set_separator(self, value):
        self._separator = self._validate_true_value(value)

    separator = property(_get_separator, _set_separator)

    def _set_title(self, value):
        self._title = self._validate_true_value(value)

    title = property(_get_title, _set_title)

    @classmethod
    def _validate_true_value(cls, value):
        # Empty lines in a popup are ignored and so a space is required for a
        # seemingly blank line.
        if not value:
            raise ValueError("expected a non-empty value")
        return value

    def send(self, user_ID, page=1, reset_navigation=True):
        """Build the popup afresh and send it to the user.

        Arguments:
        user_ID - the unique session ID of the user who should receive the
        popup.
        page (Keyword Default: 1) - the page of the menu that should be sent
        to the user.
        reset_navigation (Keyword Default: True) - whether or not the player's
        navigation history should be forgotten.

        """
        if user_ID in self.players:
            player = self.players[user_ID]
            if player._delay is not None:
                player._delay.stop()
            if reset_navigation:
                del player.history[:]
                del player.identifiers[:]
        else:
            player = self.players[user_ID] = _Player()
            player.user_ID = user_ID
        if self.get_items is not None:
            player.items[:] = self.get_items(user_ID)
        # As a result of valve's initiative, a value of 0 passed to the
        # timeout parameter no longer means infinite. The menu will
        # automatically disappear after about 5 seconds so it needs to be
        # constantly resent.
        player._delay = delays.Delay(es.menu, 0, user_ID,
                                     *self._build(user_ID, page))
        player._delay.start(4.5, True, True)
        player.popup = self, page
        player.history.append((self, page))


es.addons.registerClientCommandFilter(Menu._client_command_filter)
es.addons.registerForEvent(Menu, "player_disconnect", Menu._player_disconnect)
es.addons.registerSayFilter(Menu._say_text_filter)


class MenuItem(object):
    """Create a text-only menu item that cannot be selected."""

    def __init__(self, text="", get_text=None):
        """Instantiate a MenuItem object.

        Arguments:
        text - the text to appear in the menu for this item.
        get_text (Keyword Default: None) - the name to call to dynamically
        fetch the option's text each time the menu is built.

        """
        self.text = text
        self.get_text = get_text
        self.selectable = None


class MenuOption(object):
    """Create an numbered menu item that can be selected."""

    def __init__(self, text="", identifier=ABSENT, selectable=True,
                 get_text=None):
        """Instantiate a MenuOption object.

        Arguments:
        text (Keyword Default: "") - the text to appear in the menu for this
        item.
        identifier (Keyword Default: ABSENT) - the value to be passed to the
        menu's callback when selected.
        selectable (Keyword Default: True) - whether or not the option can be
        selected.
        get_text (Keyword Default: None) - the name to call to dynamically
        fetch the option's text each time the menu is built.

        """
        self.text = text
        self.identifier = identifier
        self.selectable = selectable
        self.get_text = get_text
        self.requires_auth = False
        self.subpopup = None

    def set_permission(self, permission=None):
        """Cause authorisation to be required by the user to select the
        option.

        Arguments:
        permission (Keyword Default: None) - the name of the permission
        requried.

        """
        self.requires_auth = True
        self.permission = permission

    def set_subpopup(self, menu, page=1, send_callback=False):
        """Cause a separate popup to be automatically sent to the user when
        they select this option.

        Arguments:
        menu - the menu object to send.
        page (Keyword Default: 1) - the page of the menu to send.
        send_callback (Keyword Default: False) - whether or not the menu's
        callback should still be called.

        """
        self.subpopup = menu, page
        self.send_callback = send_callback


class CustomMenuOption(MenuOption):
    """Create a numbered item that can be selected to then allow the player to
    input their own custom value into chat.

    """

    def __init__(self, text, transformer=None):
        """Instantiate a CustomMenuOption object.

        Arguments:
        text - the text to appear in the menu for this item.
        """
        if transformer is None:
            self.transformer = self._transformer
        super(CustomMenuOption, self).__init__(text, _CUSTOM_OPTION_IDENTIFIER)

    @staticmethod
    def _transformer(value):
        if value.isdigit():
            return int(value)
        return value


def close_popup(user_ID):
    """Effectively close a user's popup by cancelling the next resend. Raises
    an exception if the user does not have a menu open.

    Arguments:
    user_ID - the unique session ID of the user who's menu should be closed.

    """
    if user_ID in Menu.players:
        player = Menu.players[user_ID]
        if player._delay is not None:
            player._delay.stop()
            return
    raise MenusError("user ID, %s has no menu active" % user_ID)


def get_popup(user_ID):
    """Return a 2-part tuple (menu, page) of the popup last viewed by the
    user. If the user has never received a popup, return None.

    Arguments:
    user_ID - the unique session ID of the user.

    """
    if user_ID in Menu.players:
        return Menu.players[user_ID].popup
    return None

def resend_last_popup(user_ID):
    """Resend the last menu that the user selected from.

    Arguments:
    user_ID - the unique session ID of the user.

    """
    player = Menu.players[user_ID]
    del player.identifiers[-1]
    player.popup[0].send(user_ID, player.history.pop()[1], False)